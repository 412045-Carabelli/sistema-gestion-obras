import {Component, Input, OnChanges, OnInit, SimpleChanges, Output, EventEmitter} from '@angular/core';import {CurrencyPipe, formatDate, NgClass, NgIf} from '@angular/common';import {TableModule} from 'primeng/table';import {ButtonModule} from 'primeng/button';import {DropdownModule} from 'primeng/dropdown';import {InputTextModule} from 'primeng/inputtext';import {CheckboxModule} from 'primeng/checkbox';import {FormsModule} from '@angular/forms';import {MessageService} from 'primeng/api';import {ToastModule} from 'primeng/toast';import {EstadoPago, ObraCosto, Proveedor} from '../../../core/models/models';import {EstadoPagoService} from '../../../services/estado-pago/estado-pago.service';import {CostosService} from '../../../services/costos/costos.service';import {Select} from 'primeng/select';import jsPDF from 'jspdf';import autoTable from 'jspdf-autotable';@Component({  selector: 'app-obra-presupuesto',  standalone: true,  imports: [    CurrencyPipe,    TableModule,    ButtonModule,    DropdownModule,    InputTextModule,    CheckboxModule,    FormsModule,    ToastModule,    NgIf,    NgClass,    Select,  ],  providers: [MessageService],  templateUrl: './obra-presupuesto.component.html',})export class ObraPresupuestoComponent implements OnInit, OnChanges {  @Input() obraId!: number;  @Input() proveedores: Proveedor[] = [];  @Input() costos: ObraCosto[] = [];  @Input() usarBeneficioGlobal = false;  @Input() beneficioGlobal = 0;  @Input() tieneComision = false;  @Input() comision = 0;  // ? NUEVO: Emitir cuando se actualizan los costos  @Output() costosActualizados = new EventEmitter<ObraCosto[]>();  costosFiltrados: ObraCosto[] = [];  estadosPago: EstadoPago[] = [];  loading = true;  constructor(    private estadoPagoService: EstadoPagoService,    private costosService: CostosService,    private messageService: MessageService  ) {  }  ngOnInit() {    if (this.costos?.length > 0) {      this.inicializarCostos();    }    this.cargarEstadosDePago();  }  ngOnChanges(changes: SimpleChanges) {    if (changes['costos'] && this.costos?.length > 0) {      this.inicializarCostos();    }  }  actualizarEstadoPago(c: ObraCosto, nuevoId: number) {    const nuevoEstado = this.estadosPago.find((e) => e.id === nuevoId);    if (!nuevoEstado) return;    this.costosService.updateEstadoPago(c.id!, nuevoId).subscribe({      next: () => {        c.estado_pago = nuevoId;        c.id_estado_pago = nuevoId;        // ? ACTUALIZAR EL ARRAY DE COSTOS ORIGINAL        const index = this.costos.findIndex(costo => costo.id === c.id);        if (index !== -1) {          this.costos[index] = {...this.costos[index], estado_pago: nuevoId, id_estado_pago: nuevoId};        }        // ? EMITIR EL ARRAY ACTUALIZADO        this.costosActualizados.emit([...this.costos]);        this.messageService.add({          severity: 'success',          summary: 'Estado actualizado',          detail: `El costo fue marcado como "${nuevoEstado.estado}"`,        });      },      error: (err) => {        console.error('? Error al actualizar estado de pago', err);        this.messageService.add({          severity: 'error',          summary: 'Error',          detail: 'No se pudo actualizar el estado de pago',        });      }    });  }  calcularTotal(): number {    return this.costosFiltrados.reduce((acc, c) => acc + (c.total ?? 0), 0);  }  calcularTotalPorEstado(nombreEstado: string): number {    const estado = this.estadosPago.find(      (e) => e.estado.toLowerCase() === nombreEstado.toLowerCase()    );    if (!estado) return 0;    return this.costosFiltrados      .filter((c) => (c.estado_pago ?? c.id_estado_pago) === estado.id)      .reduce((acc, c) => acc + (c.total ?? 0), 0);  }  getPresupuestoTotal(): number {    const subtotal = this.calcularTotal();    const beneficio = this.usarBeneficioGlobal ? this.beneficioGlobal : 0;    const comision = this.tieneComision ? this.comision : 0;    return Math.round(subtotal * (1 + beneficio / 100) * (1 + comision / 100));  }  proveedoresFilter(id: number): Proveedor | undefined {    return this.proveedores?.find((p) => Number(p.id) === Number(id));  }  async exportarPDF() {  const doc = new jsPDF('p', 'mm', 'a4');  const pageWidth = doc.internal.pageSize.getWidth();  // === LOGO ===  const logo = '/assets/img/meliquina-logo.jpg'; // ?? poné el path a tu imagen o convertí a Base64  const logoWidth = 60;  const logoHeight = 20;  const xLogo = (pageWidth - logoWidth) / 2;  try {    const logoDataUrl = await this.loadImageAsDataURL('assets/img/meliquina-logo.jpg');    doc.addImage(logoDataUrl, 'JPEG', xLogo, 10, logoWidth, logoHeight);  } catch (e) {    console.warn('No se pudo cargar el logo para el PDF', e);    this.messageService.add({      severity: 'warn',      summary: 'Logo no disponible',      detail: 'No se pudo cargar el logo en el PDF.'    });  }  // === TÍTULO ===  doc.setFontSize(16);  doc.text('PRESUPUESTO DE OBRA', pageWidth / 2, 40, { align: 'center' });  const fecha = formatDate(new Date(), 'dd/MM/yyyy', 'es-AR');  doc.setFontSize(10);  doc.text(`Fecha: ${fecha}`, pageWidth - 20, 50, { align: 'right' });  // === TABLA DE COSTOS ===  const body = this.costosFiltrados.map((c) => [    this.proveedoresFilter(c.id_proveedor!)?.nombre ?? '—',    c.descripcion,    c.cantidad,    c.unidad ?? '',    c.precio_unitario?.toLocaleString('es-AR', { style: 'currency', currency: 'ARS' }),    `${c.beneficio ?? 0}%`,    c.total?.toLocaleString('es-AR', { style: 'currency', currency: 'ARS' }),    this.estadosPago.find(e => e.id === c.id_estado_pago)?.estado ?? '—'  ]);  autoTable(doc, {    startY: 60,    head: [[      'Proveedor', 'Descripción', 'Cantidad', 'Unidad',      'Precio Unitario', 'Beneficio', 'Total', 'Estado de Pago'    ]],    body,    styles: { fontSize: 9 },    headStyles: { fillColor: [255, 180, 0], textColor: [0, 0, 0] }, // naranja Meliquina    alternateRowStyles: { fillColor: [250, 250, 250] },  });  // === TOTALES ===  const y = (doc as any).lastAutoTable.finalY + 10;  doc.setFontSize(11);  doc.text(`Subtotal: ${this.calcularTotal().toLocaleString('es-AR', { style: 'currency', currency: 'ARS' })}`, pageWidth - 20, y, { align: 'right' });  let yOffset = y + 6;  if (this.usarBeneficioGlobal) {    doc.text(`Beneficio Global (${this.beneficioGlobal}%): +${((this.calcularTotal() * this.beneficioGlobal) / 100)      .toLocaleString('es-AR', { style: 'currency', currency: 'ARS' })}`, pageWidth - 20, yOffset, { align: 'right' });    yOffset += 6;  }  if (this.tieneComision) {    doc.text(`Comisión (${this.comision}%): +${((this.calcularTotal() * this.comision) / 100)      .toLocaleString('es-AR', { style: 'currency', currency: 'ARS' })}`, pageWidth - 20, yOffset, { align: 'right' });    yOffset += 6;  }  const totalFinal = this.getPresupuestoTotal();  doc.setFontSize(13);  doc.setFont('Arial', 'bold');  doc.text(`TOTAL: ${totalFinal.toLocaleString('es-AR', { style: 'currency', currency: 'ARS' })}`, pageWidth - 20, yOffset + 6, { align: 'right' });  // === PIE DE PÁGINA ===  doc.setFontSize(9);  doc.setFont('Arial', 'normal');  doc.text('Meliquina Construcciones — Presupuesto generado automáticamente', pageWidth / 2, 285, { align: 'center' });  // === DESCARGAR ===  doc.save(`Presupuesto_Obra_${fecha}.pdf`);  }  private async loadImageAsDataURL(url: string): Promise<string> {    const response = await fetch(url);    if (!response.ok) {      throw new Error(`HTTP ${response.status} cargando ${url}`);    }    const blob = await response.blob();    return await new Promise((resolve, reject) => {      const reader = new FileReader();      reader.onloadend = () => resolve(reader.result as string);      reader.onerror = reject;      reader.readAsDataURL(blob);    });  }private inicializarCostos() {    // Aseguramos campos no nulos y un estado de pago por defecto    this.costosFiltrados = this.costos.map((c) => ({      ...c,      precio_unitario: c.precio_unitario ?? 0,      subtotal: c.subtotal ?? 0,      total: c.total ?? 0,      beneficio: c.beneficio ?? 0,      estado_pago: (c as any).estado_pago ?? c.id_estado_pago ?? 1,      id_estado_pago: c.id_estado_pago ?? (c as any).estado_pago ?? 1,    }));  }  private cargarEstadosDePago() {    this.estadoPagoService.getEstadosPago().subscribe({      next: (estados) => {        console.log(estados)        this.estadosPago = estados.map((e) => ({          id: e.id,          estado: e.estado,        }));        this.loading = false;      },      error: (err) => {        console.error('? Error al cargar estados de pago', err);        this.loading = false;      },    });  }}